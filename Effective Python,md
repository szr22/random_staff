# 1. Pythonic Thinking

## ITEM 1: KNOW WHICH VERSION OF PYTHON YOU’RE USING

## ITEM 2: FOLLOW THE PEP 8 STYLE GUIDE
1. Whitespace
2. Naming
3. Expressions and Statements

## ITEM 3: KNOW THE DIFFERENCES BETWEEN BYTES, STR, AND UNICODE
1. In Python 3, bytes and str instances are never equivalent—not even the empty string
2. The second issue is that in Python 3, operations involving file handles (returned by the open built-in function) default to UTF-8 encoding

In Python 3, bytes contains sequences of 8-bit values, str contains sequences of Unicode characters

## ITEM 4: WRITE HELPER FUNCTIONS INSTEAD OF COMPLEX EXPRESSIONS

## ITEM 5: KNOW HOW TO SLICE SEQUENCES
somelist[start:end], where start is inclusive and end is exclusive

## ITEM 6: AVOID USING START, END, AND STRIDE IN A SINGLE SLICE

## ITEM 7: USE LIST COMPREHENSIONS INSTEAD OF MAP AND FILTER

## ITEM 8: AVOID MORE THAN TWO EXPRESSIONS IN LIST COMPREHENSIONS

## ITEM 9: CONSIDER GENERATOR EXPRESSIONS FOR LARGE COMPREHENSIONS

## ITEM 10: PREFER ENUMERATE OVER RANGE

## ITEM 11: USE ZIP TO PROCESS ITERATORS IN PARALLEL

## ITEM 12: AVOID ELSE BLOCKS AFTER FOR AND WHILE LOOPS

## ITEM 13: TAKE ADVANTAGE OF EACH BLOCK IN TRY/EXCEPT/ELSE/FINALLY
try/except/else/finally

# 2. Functions

## ITEM 14: PREFER EXCEPTIONS TO RETURNING NONE
```
def divide(a, b):
    try:
        return True, a / b
    except ZeroDivisionError:
        return False, None
```
or 
```
def divide(a, b):
    try:
        return a / b
    except ZeroDivisionError as e:
        raise ValueError('Invalid inputs') from e
```

## ITEM 15: KNOW HOW CLOSURES INTERACT WITH VARIABLE SCOPE
Bad:
'''
def sort_priority(values, group):
    def helper(x):
        if x in group:
            return (0, x)
        return (1, x)
    values.sort(key=helper)

numbers = [8, 3, 1, 2, 5, 4, 7, 6]
group = {2, 3, 5, 7}
sort_priority(numbers, group)
print(numbers)
'''

Good:
'''
def sort_priority3(numbers, group):
    found = False
    def helper(x):
        nonlocal found
        if x in group:
            found = True
            return (0, x)
        return (1, x)
    numbers.sort(key=helper)
    return found
'''

Better:
'''
class Sorter(object):
    def __init__(self, group):
        self.group = group
        self.found = False

    def __call__(self, x):
        if x in self.group:
            self.found = True
            return (0, x)
        return (1, x)

sorter = Sorter(group)
numbers.sort(key=sorter)
'''

note: Python has specific rules for comparing tuples. It first compares items in index zero, then index one, then index two, and so on. This is why the return value from the helper closure causes the sort order to have two distinct groups.

variable resolve order
1. The current function’s scope
2. Any enclosing scopes (like other containing functions)
3. The scope of the module that contains the code (also called the global scope)
4. The built-in scope (that contains functions like len and str)

5. (exception) If none of these places have a defined variable with the referenced name, then a NameError exception is raised.

## ITEM 16: CONSIDER GENERATORS INSTEAD OF RETURNING LISTS
good
'''
def index_words_iter(text):
    if text:
        yield 0
    for index, letter in enumerate(text):
        if letter == ' ':
            yield index + 1
result = list(index_words_iter(address))

'''
better
'''
def index_file(handle):
    offset = 0
    for line in handle:
        if line:
            yield offset
        for letter in line:
            offset += 1
            if letter == ' ':
               yield offset
'''

## ITEM 17: BE DEFENSIVE WHEN ITERATING OVER ARGUMENTS
Good
pass in a lambda expression that calls the generator and produces a new iterator each time.
'''
def normalize_func(get_iter):
    total = sum(get_iter())   # New iterator
    result = []
    for value in get_iter():  # New iterator
        percent = 100 * value / total
        result.append(percent)
    return result
'''

Better
'''
class ReadVisits(object):
    def __init__(self, data_path):
        self.data_path = data_path

    def __iter__(self):
        with open(self.data_path) as f:
            for line in f:
                yield int(line)

visits = ReadVisits(path)
percentages = normalize(visits)
print(percentages)
'''

## ITEM 18: REDUCE VISUAL NOISE WITH VARIABLE POSITIONAL ARGUMENTS
Good
'''
def log(message, *values):  # The only difference
    if not values:
        print(message)
    else:
        values_str = ', '.join(str(x) for x in values)
        print('%s: %s' % (message, values_str))

log('My numbers are', 1, 2)
log('Hi there')  # Much better
'''

Better
'''
def my_generator():
    for i in range(10):
        yield i

def my_func(*args):
    print(args)

it = my_generator()
my_func(*it)
'''

## ITEM 19: PROVIDE OPTIONAL BEHAVIOR WITH KEYWORD ARGUMENTS

## ITEM 20: USE NONE AND DOCSTRINGS TO SPECIFY DYNAMIC DEFAULT ARGUMENTS
Default arguments are only evaluated once: during function definition at module load time. This can cause odd behaviors for dynamic values (like {} or [])
Use None as the default value for keyword arguments that have a dynamic value. Document the actual default behavior in the function’s docstring.

## ITEM 21: ENFORCE CLARITY WITH KEYWORD-ONLY ARGUMENTS

# 3. Classes and Inheritance
inheritance, polymorphism, and encapsulation

## ITEM 22: PREFER HELPER CLASSES OVER BOOKKEEPING WITH DICTIONARIES AND TUPLES
Avoid making dictionaries with values that are other dictionaries or long tuples.
Use namedtuple for lightweight, immutable data containers before you need the flexibility of a full class.
Move your bookkeeping code to use multiple helper classes when your internal state dictionaries get complicated.

## ITEM 23: ACCEPT FUNCTIONS FOR SIMPLE INTERFACES INSTEAD OF CLASSES
Instead of defining and instantiating classes, functions are often all you need for simple interfaces between components in Python.
References to functions and methods in Python are first class, meaning they can be used in expressions like any other type.
The __call__ special method enables instances of a class to be called like plain Python functions.
When you need a function to maintain state, consider defining a class that provides the __call__ method instead of defining a stateful closure

## ITEM 24: USE @CLASSMETHOD POLYMORPHISM TO CONSTRUCT OBJECTS GENERICALLY
'''
def generate_inputs(data_dir):
    for name in os.listdir(data_dir):
        yield PathInputData(os.path.join(data_dir, name))

def create_workers(input_list):
    workers = []
    for input_data in input_list:
        workers.append(LineCountWorker(input_data))
    return workers

def execute(workers):
    threads = [Thread(target=w.map) for w in workers]
    for thread in threads: thread.start()
    for thread in threads: thread.join()

    first, rest = workers[0], workers[1:]
    for worker in rest:
        first.reduce(worker)
    return first.result
    
def mapreduce(data_dir):
    inputs = generate_inputs(data_dir)
    workers = create_workers(inputs)
    return execute(workers)
'''
class
'''
class GenericInputData(object):
    def read(self):
        raise NotImplementedError

    @classmethod
    def generate_inputs(cls, config):
        raise NotImplementedError

class PathInputData(GenericInputData):
    # ...
    def read(self):
        return open(self.path).read()

    @classmethod
    def generate_inputs(cls, config):
        data_dir = config['data_dir']
        for name in os.listdir(data_dir):
            yield cls(os.path.join(data_dir, name))

class GenericWorker(object):
    # ...
    def map(self):
        raise NotImplementedError

    def reduce(self, other):
        raise NotImplementedError

    @classmethod
    def create_workers(cls, input_class, config):
        workers = []
        for input_data in input_class.generate_inputs(config):
            workers.append(cls(input_data))
        return workers
'''

Python only supports a single constructor per class, the __init__ method
Use @classmethod to define alternative constructors for your classes.
Use class method polymorphism to provide generic ways to build and connect concrete subclasses.

## ITEM 25: INITIALIZE PARENT CLASSES WITH SUPER
Python’s standard method resolution order (MRO) solves the problems of superclass initialization order and diamond inheritance.
Always use the super built-in function to initialize parent classes.

## ITEM 26: USE MULTIPLE INHERITANCE ONLY FOR MIX-IN UTILITY CLASSES

